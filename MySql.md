

### MySQL 基础架构
![MySQL架构](res/MySQL_res/1.png)
* 连接器： 身份认证和权限相关(登录 MySQL 的时候)。
* 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
* 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
* 优化器： 按照 MySQL 认为最优的方案去执行。
* 执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
* 插件式存储引擎 ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。
### 存储引擎
可以通过 `show engines `命令来查看 MySQL 支持的所有存储引擎。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB(唯一支持事务的) 是 MySQL 的默认存储引擎。
#### 存储引擎的架构
MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。
####  InnoDB与MyISAM
一般使用InnoDB，某些读密集的情况下，使用 MyISAM 也是合适的（但会放弃事务支持等一系列InnoDB的优点）。
|InnoDB|MyISAM|
|---|---|
|支持行级锁(row-level locking)和表级锁,默认为行级锁。|只有表级锁(table-level locking)|
|提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。默认使用的可重复读隔离级别。|不提供事务支持|
|支持外键|不支持外键|
|支持数据库异常崩溃后的安全恢复|不支持数据库异常崩溃后的安全恢复|
|支持MVCC（多版本并发控制）|不支持MVCC|
|使用 B+Tree 作为索引结构，其数据文件本身就是索引文件|使用 B+Tree 作为索引结构,索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录|
### 事务
事务是逻辑上的一组操作，要么都执行，要么都不执行。
#### 数据库事务的ACID特性
只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的。
1. 原子性（Atomicity）： 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
2. 一致性（Consistency）： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏，数据保持一致。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
3. 隔离性（Isolation）： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
   * 未提交读:正在执行的事务 读取到其他事物未提交的数据,会导致脏读。
   * 提交读：正在执行的事务 读取到其他事务已提交的数据 读取到其他事务已提交的修改 造成了不可重读，会造成不可重复读。
   * 可重复读：正在执行的事务 读取不到其他事务已提交或未提交的修改，但能读到其他事务已提交的插入，会造成幻读。
   * 可串行化： 最高的默认级别，强制事务串行执行（即一个事务一个事务执行）。效率极其低下。
4. 持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
#### 并发事务带来的问题
1. 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
2. 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
3. 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
4. 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
#### MySQL保证原子性
想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在 MySQL 中，恢复机制是通过 回滚日志（undo log） 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。
#### 隔离级别的实现
SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。但可能会用到锁机制，如REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。
### 锁
#### 行级锁与表级锁
* 表级锁： MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
* 行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
#### 共享锁和排他锁
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：
* 共享锁（S 锁） ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）
* 排他锁（X 锁） ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。
且排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。
#### 意向锁
用于快速判断是否可以对某个表使用表锁。它属于表级锁，分为：
* 意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
* 意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。
意向锁是有数据引擎自己维护的，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。且意向锁之间是互相兼容的，但其意向排他锁和共享锁和排它锁互斥（表级别的）。
#### InnoDB的行锁
1. 记录锁（Record Lock） ：属于单个行记录上的锁。
2. 间隙锁（Gap Lock） ：索引记录之间的间隙上的锁，锁定一个范围，不包括记录本身。如果其他事务想要在这个范围内插入该范围不存在的数据时就会被阻塞。
3. 临键锁（Next-key Lock） ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。
#### 当前读和快照读
1. 快照读（一致性非锁定读）就是单纯的 SELECT 语句，由 MVCC 机制来保证不出现幻读。除了以下两种都是快照读
```sql
SELECT ... FOR UPDATE
SELECT ... LOCK IN SHARE MODE
```
   * 如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。
   * 只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：（1）在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。（2）在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。
   * 快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。
2. 当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。 使用 Next-Key Lock 进行加锁来保证不出现幻读

### 索引
索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。
#### 索引类型
1. 主键索引，即数据表的主键
2. 二级索引(辅助索引)，通过二级索引，可以定位主键的位置。
   * 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
   * 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。
   * 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
   * 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。
#### 聚集索引与非聚集索引
##### 聚集索引
索引结构和数据一起存放的索引。主键索引属于聚集索引。
1. 优点：聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。
2. 缺点： 
   * 依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
   * 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的
##### 非聚集索引
非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。
1. 优点：更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的
2. 缺点： 
   * 跟聚集索引一样，非聚集索引也依赖于有序的数据
   * 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。
3. 索引下推：可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。
#### 覆盖索引
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。
#### 联合索引 
即使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。
##### 最左前缀匹配原则
在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。
### 性能优化
1. 数据库和表的字符集统一使用 UTF8
2. 所有表和字段都需要添加注释，从一开始就进行数据字典的维护
3. 尽量控制单表数据量的大小，建议控制在 500 万以内，过大会造成修改表结构，备份，恢复都会有很大的问题。可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小
4. 谨慎使用 MySQL 分区表，跨分区查询效率可能更低；建议采用物理分表的方式管理大数据。
5. 禁止在表中建立预留字段，其命名很难做到见名识义，且无法确认存储的数据类型，所以无法选择合适的类型。
6. 禁止在数据库中存储文件（比如图片）这类大的二进制数据
7. 不要被数据库范式所束缚，一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。
8. 禁止从开发环境,测试环境直接连接生产环境数据库，以防止对生产环境的干扰，造成损失。
9. 优先选择符合存储需要的最小的数据类型
    * 某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整形数据。INET_ATON() ： 把 ip 转为无符号整型 (4-8 位)；INET_NTOA() :把整型的 ip 转为地址
    * 对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储
    * 小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型
10. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据
    * MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差。
    * 因为 MySQL 对索引字段长度是有限制的，所以 TEXT 或 BLOB 类型只能使用前缀索引
    * 查询时一定不要使用 select *而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。
11. 避免使用 ENUM 类型：修改 ENUM 值需要使用 ALTER 语句，且 ORDER BY 操作效率低，需要额外操作
12. 尽可能把所有列定义为 NOT NULL，索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；且进行比较和计算时要对 NULL 值做特别的处理
13. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间
14. 限制每张表上的索引数量,建议单张表索引不超过 5 个
15. 禁止给表中的每一列都建立单独的索引
16. 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）
17. 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）
18. 主键建议使用自增 ID 值
19. 索引列的顺序：
    * 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）
    * 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
    * 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）
20. 对于频繁的查询优先考虑使用覆盖索引，即包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引
21. 禁止使用不含字段列表的 INSERT 语句
22. 建议使用预编译语句进行数据库操作，即Mybatis中使用#{}
23. 避免数据类型的隐式转换，隐式转换会导致索引失效
24. 避免使用子查询，可以把子查询优化为 join 操作。子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响
25. 对应同一列进行 or 判断时，使用 in 代替 or，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。
26. WHERE 从句中禁止对列进行函数转换和计算，对列进行函数转换或计算时会导致无法使用索引。
27. 程序连接不同的数据库使用不同的账号，禁止跨库查询；对于程序连接数据库账号,遵循权限最小原则
28. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作，大批量操作可能会造成严重的主从延迟



### 基本知识
#### 建表规范

|范式|说明|
|---|---|
| Normal Format, NF|每个表保存一个实体信息，每个具有一个ID字段作为主键，ID主键 + 原子表|
|1NF, 第一范式|字段不能再分，就满足第一范式。|
|2NF, 第二范式|满足第一范式的前提下，不能出现部分依赖。消除复合主键就可以避免部分依赖。增加单列关键字。|
|3NF, 第三范式|满足第二范式的前提下，不能出现传递依赖。某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。将一个实体信息的数据放在一个表内实现。要求一个关系不包含已在其他关系中已包含的非关键字信息|
#### 查询语句
```sql
SELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [合计函数] -> HAVING -> ORDER BY -> LIMIT
```
1. HAVING 子句，条件子句。与 where 功能、用法相同，执行时机不同。
   
   |having|where|
   |---|---|
   |对筛选出的结果再次进行过滤。|在开始时执行检测数据，对原数据进行过滤。|
   |字段必须是查询出来的|字段必须是数据表存在的|
   |可以使用字段的别名|可以使用字段的别名|
   |可以使用合计函数|不可以使用合计函数|
2. LIMIT 子句，限制结果数量子句。仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。```limit 起始位置, 获取条数```
3. 分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。当一条sql语句没有group by，整张表的数据会自成一组。

#### UNION
1. 将多个select查询的结果组合成一个结果集合。默认 DISTINCT 方式，即所有返回的行都是唯一的
2. 需要各select查询的字段数量一样。每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。
#### 子查询
需要用括号包裹
1. from型
   * from后要求是一个表，必须给子查询结果取个别名。一般用于简化每个查询内的条件
2. where型
   * 子查询返回一个值，标量子查询。
   * 不需要给子查询取别名。
   * where子查询内的表，不能直接用以更新。
   * 当子查询返回的是行，采用如下方式
```sql
select * from t1 where (id, gender) in (select id, gender from t2);
```
#### 连接查询（join）
将多个表的字段进行连接，可以指定连接条件。on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真），也可用where表示连接条件。还有 using, 但需字段名相同。 using(字段名)
1. 内连接(inner join)
   * 默认的连接
   * 只有数据存在时才能发送连接。即连接结果不能出现空行。
2. 外连接(outer join)
   * 分为左外连接和右外连接：把左（右）边表的内容全部查出,右（左）边表只查出满足条件的记录
   * 如果数据不存在，也会出现在连接结果中。以NULL填充
3. 自然连接(natural join)
   * 自动判断连接条件完成连接。相当于省略了using，会自动查找相同字段名。
   * 不能指定匹配条件，加‘on’会报错

#### 视图 
视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。它具有表结构文件，但不存在数据文件。对其中所引用的基础表来说，视图的作用类似于筛选。
定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。
1. 创建视图
```sql
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
```
   * 视图名必须唯一，同时不能与表重名。
   * 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
   * 可以指定视图执行的算法，通过ALGORITHM指定。
   * column_list如果存在，则数目必须等于SELECT语句检索的列数
   * SELECT 语句不能包含 FROM 子句中的子查询。
   * 定义时可以带上WITH CHECK OPTION约束,使对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制。
2.视图算法(ALGORITHM)
   * MERGE       合并,将视图的查询语句，与外部查询先合并再执行.
   * TEMPTABLE   临时表,将视图执行完毕后，形成临时表，再做外层查询.
   * UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。
  
### 注意事项
#### 数据库设计
1. 不建议在实际生产项目中使用外键的，在业务代码中进行约束即可。这也是阿里《JAVA开发手册》的要求
2. 主键可以由多个字段共同组成。
3. 自动增长必须为索引（主键或unique）且只能存在一个字段为自动增长。
4. 所有存储相同数据的列名和列类型必须一致
5. 同财务相关的金额类数据必须使用 decimal（总位数，小数位数） 类型，其不会丢失精度，占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据
6. 常见索引列建议
   * 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
   * 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
   * 并不要将符合 前两个条件中的字段的列都建立一个索引， 通常将其建立联合索引效果更好
   * 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
   * 多表 join 的关联列
   * 尽可能的考虑建立联合索引而不是单列索引。
7. 非聚集索引不一定回表查询，因为查询列可能刚好就是索引。
8. 考虑在字符串类型的字段上使用前缀索引代替普通索引。前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。
#### 锁相关   
1. 行级锁产生死锁，例：第一条语句会优先使用`name`索引，因为name不是主键索引，还会用到主键索引第二条语句是首先使用主键索引,再使用name索引 如果两条语句同时执行，第一条语句执行了name索引等待第二条释放主键索引，第二条执行了主键索引等待第一条的name索引，这样就造成了死锁。
* 解决方法：改造第一条语句 使其根据主键值进行更新
```sql
#①
update mk_user set name ='1' where `name`='idis12';
#②
update mk_user set name='12'  where id=12;
//改造后
update mk_user set name='1' where id=(select id from mk_user where name='idis12' );
```
2. 当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。
3. 由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁
#### 存储类型
1.  一条有效记录最大不能超过65535个字节。
2.  char,定长，最多255个字符，与编码无关
3.  varchar,变长，最多65535字符，与编码有关。需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。且存储字符串时，第一个字节是空的。 varchar 的最大有效长度由最大行大小和使用的字符集确定。理论最大值为65532字节。
4.  text 类型在定义时，不可给default值
5.  enum类型 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。表现为字符串类型，存储却是整型。
#### 数据库操作
1. 当group by 与聚合函数，非聚合字段（不在group by和聚合函数中）同时使用时，非聚合字段的取值是第一个匹配到的字段内容，即id小的条目对应的字段内容。
2. 如果MySQL处于严格模式（sql_mode被设置为ONLY_FULL_GROUP_BY），SQL写成select * from t group by name,就会报错，原因就是因为除了name之前，其他列的数据都不是唯一的，在严格模式会报错。
   * 方法一：使用ANY_VALUE(非聚合列)进行查询，
   * 方法二：如果GROUP BY是主键或者 unique NOT NULL 时是可以查询非聚合的列的，原因是此时分组的key是主键，则每一个分组只有一条数据，因此是可以进行查询非聚合的列的。
   * 方法三：关闭严格模式
3. 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。
4. 避免 where 子句中对字段施加函数，这会造成无法命中索引。

